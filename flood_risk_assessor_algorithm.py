# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FloodRisk
                                 A QGIS plugin
 This plugin works by assessing the risk of flooding in areas
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        copyright            : (C) 2024 by Group 3
        email                : bsc-inf-05-20@unima.ac.mw
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Group 3'
__date__ = '2024-11-29'
__copyright__ = '(C) 2024 by Group 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

# -*- coding: utf-8 -*-
"""
Flood Risk Assessment Algorithm
"""

from qgis.PyQt.QtCore import QCoreApplication # type: ignore
from qgis.core import ( # type: ignore
    QgsProcessingAlgorithm,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterVectorLayer,
    QgsProcessingParameterNumber,
    QgsProcessingParameterFeatureSink,
    QgsProcessing,
    QgsFeatureSink,
    QgsVectorLayer,  
    QgsWkbTypes
)
import processing # type: ignore
import os

class FloodRiskAlgorithm(QgsProcessingAlgorithm):
    DEM = "DEM"
    BUILDINGS = "BUILDINGS"
    WATERWAYS = "WATERWAYS"
    ELEVATION_THRESHOLD = "ELEVATION_THRESHOLD"
    BUFFER_DISTANCE = "BUFFER_DISTANCE"
    FLOOD_ZONES = "FLOOD_ZONES"
    AFFECTED_BUILDINGS = "AFFECTED_BUILDINGS"

    def initAlgorithm(self, config=None):
    # Input DEM
        self.addParameter(
        QgsProcessingParameterRasterLayer(self.DEM, "Digital Elevation Model (DEM)")
        )
    # Input buildings shapefile
        self.addParameter(
        QgsProcessingParameterVectorLayer(self.BUILDINGS, "Buildings Layer", [QgsProcessing.TypeVectorPolygon])
        )
    # Input waterways shapefile
        self.addParameter(
        QgsProcessingParameterVectorLayer(self.WATERWAYS, "Waterways Layer", [QgsProcessing.TypeVectorLine])
        )
    # Elevation threshold for flooding
        self.addParameter(
            QgsProcessingParameterNumber(
                self.ELEVATION_THRESHOLD, "Flood Elevation Threshold (meters)", 
                type=QgsProcessingParameterNumber.Double, 
                defaultValue=2
            )
        )
    # Buffer distance for waterways
        self.addParameter(
            QgsProcessingParameterNumber(
                self.BUFFER_DISTANCE, "Waterways Buffer Distance (meters)", 
                type=QgsProcessingParameterNumber.Double, 
                defaultValue=100
            )
        )
    # Outputs
        self.addParameter(
            QgsProcessingParameterFeatureSink(self.FLOOD_ZONES, "Flood Zones")
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(self.AFFECTED_BUILDINGS, "Affected Buildings")
        )


    def processAlgorithm(self, parameters, context, feedback):
        
        temp_dir = "C:/temp/"
        if not os.path.exists(temp_dir):
            os.makedirs(temp_dir)
    # Step 1: Retrieve inputs
        dem_layer = self.parameterAsRasterLayer(parameters, self.DEM, context)
        buildings_layer = self.parameterAsVectorLayer(parameters, self.BUILDINGS, context)
        waterways_layer = self.parameterAsVectorLayer(parameters, self.WATERWAYS, context)
        elevation_threshold = self.parameterAsDouble(parameters, self.ELEVATION_THRESHOLD, context)
        buffer_distance = self.parameterAsDouble(parameters, self.BUFFER_DISTANCE, context)

        if not dem_layer or not buildings_layer or not waterways_layer:
            raise QgsProcessingException("One or more input layers are missing or invalid!")
        if not buildings_layer:
            raise QgsProcessingException("Buildings layer is invalid or missing!")
        if not waterways_layer:
            raise QgsProcessingException("Waterways layer is invalid or missing!")

    # Step 2: Calculate flood zones from DEM
        feedback.pushInfo("Calculating flood zones...")
        flood_zones_raster = processing.run("gdal:rastercalculator", {
            'INPUT_A': dem_layer,
            'BAND_A': 1,
            'FORMULA': f"A <= {elevation_threshold}",
            'OUTPUT': 'C:/temp/flood_zones_raster.tif'  # Save output to disk
        }, context=context, feedback=feedback)['OUTPUT']

        flood_zones_vector = processing.run("gdal:polygonize", {
            'INPUT': flood_zones_raster,
            'OUTPUT': 'C:/temp/flood_zones_vector.shp'  # Save output to disk
        }, context=context, feedback=feedback)['OUTPUT']

    # Step 3: Buffer waterways
        feedback.pushInfo("Buffering waterways...")
        buffered_waterways = processing.run("native:buffer", {
            'INPUT': waterways_layer,
            'DISTANCE': buffer_distance,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

# Step 4: Merge and combine flood zones and buffered waterways
        # Step 4: Merge and combine flood zones and buffered waterways
        feedback.pushInfo("Merging flood zones and waterways...")
        merged_layer = processing.run("native:mergevectorlayers", {
            'LAYERS': [flood_zones_vector, buffered_waterways],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

        feedback.pushInfo("Combining flood zones and waterways...")
        combined_flood_zones = processing.run("native:union", {
            'INPUT': merged_layer,
            'OVERLAY': merged_layer,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

        # Validation: Ensure the combined_flood_zones layer exists and contains features
        if combined_flood_zones is None:
            feedback.reportError("Error: Combined flood zones layer could not be created.")
            return {}

        if not any(combined_flood_zones.getFeatures()):
            feedback.reportError("Error: Combined flood zones layer is empty.")
            return {}

        feedback.pushInfo("Combined flood zones layer created successfully.")

    # Step 5: Assess affected buildings
        # Step 5: Assess affected buildings
        feedback.pushInfo("Identifying affected buildings...")
        affected_buildings = processing.run("qgis:extractbylocation", {
            'INPUT': buildings_layer,
            'PREDICATE': [0],  # Ensure this is a list of valid predicates
            'INTERSECT': combined_flood_zones,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

    # Step 6: Output results
        feedback.pushInfo("Returning results...")
        flood_zones_sink, flood_zones_id = self.parameterAsSink(
            parameters, self.FLOOD_ZONES, context,
            QgsVectorLayer('C:/temp/combined_flood_zones.shp').fields(),
            QgsWkbTypes.MultiPolygon,
            QgsVectorLayer('C:/temp/combined_flood_zones.shp').crs()
        )

        affected_buildings_sink, affected_buildings_id = self.parameterAsSink(
            parameters, self.AFFECTED_BUILDINGS, context,
            QgsVectorLayer('C:/temp/affected_buildings.shp').fields(),
            QgsWkbTypes.MultiPolygon,
            QgsVectorLayer('C:/temp/affected_buildings.shp').crs()
        )

        return {self.FLOOD_ZONES: flood_zones_id, self.AFFECTED_BUILDINGS: affected_buildings_id}

    def name(self):
        return "floodrisk"

    def displayName(self):
        return "Flood Risk Assessment"

    def group(self):
        return "Flood Risk Tools"

    def groupId(self):
        return "flood_risk_tools"

    def createInstance(self):
        return FloodRiskAlgorithm()
